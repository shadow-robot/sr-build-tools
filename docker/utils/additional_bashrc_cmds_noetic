# Print nickname for git/hg/bzr/svn version control in CWD
# Optional $1 of format string for printf, default "(%s) "
if [ -f /etc/bash_completion.d/git ]; then
    . /etc/bash_completion.d/git
fi
if [ -f /etc/bash_completion.d/git-prompt ]; then
    . /etc/bash_completion.d/git-prompt
fi
if [ -f /usr/share/bash-completion/completions/git ]; then
    . /usr/share/bash-completion/completions/git
fi

function be_get_branch {
  local dir="$PWD"
  local vcs
  local nick
  while [[ "$dir" != "/" ]]; do
    for vcs in git hg svn bzr; do
      if [[ -d "$dir/.$vcs" ]] && hash "$vcs" &>/dev/null; then
        case "$vcs" in
          git) __git_ps1 "${1:-(%s) }"; return;;
          hg) nick=$(hg branch 2>/dev/null);;
          svn) nick=$(svn info 2>/dev/null\
                | grep -e '^Repository Root:'\
                | sed -e 's#.*/##');;
          bzr)
            local conf="${dir}/.bzr/branch/branch.conf" # normal branch
            [[ -f "$conf" ]] && nick=$(grep -E '^nickname =' "$conf" | cut -d' ' -f 3)
            conf="${dir}/.bzr/branch/location" # colo/lightweight branch
            [[ -z "$nick" ]] && [[ -f "$conf" ]] && nick="$(basename "$(< $conf)")"
            [[ -z "$nick" ]] && nick="$(basename "$(readlink -f "$dir")")";;
        esac
        [[ -n "$nick" ]] && printf "${1:-(%s) }" "$nick"
        return 0
      fi
    done
    dir="$(dirname "$dir")"
  done
}

# Add branch to PS1 (based on $PS1 or $1), formatted as $2
export GIT_PS1_SHOWDIRTYSTATE=yes

#pretty PS1:
export PS1="\$([[ \$? != 0 ]] && echo \"[\[\033[0;31m\]\342\234\227\[\033[0;37m\]]\342\224\200\")[$(if [[ ${EUID} == 0 ]]; then echo '\[\033[0;31m\]\h'; else echo '\[\033[0;33m\]\u\[\033[0;37m\]@\[\033[0;95m\]\h'; fi)\[\033[0;37m\]]\342\224\200[\[\033[0;32m\]\w\[\033[0;37m\]]\n\[\033[0;37m\]\342\224\224\342\224\200\342\224\200\342\225\274 \[\033[0m\]"
export PS1="\[\033[0;37m\]\342\224\214\342\224\200\$(be_get_branch "$2")${PS1}";

#Function to be able to catkin_make in any subfolder
function catkin_make_here {
    local startdir
    local go
    local count
    local end
    startdir=$(pwd)
    go=1
    while [ $go == 1 ]
    do
    count=$(pwd | grep -c '/src/')
    end=$(pwd | grep -c src$)
    if [ $count == 0 ] && [ $end == 0 ]
    then
        go=0
    else
        cd ..
    fi
    done
    catkin_make
    cd $startdir
}

alias depmelodic='rosdep install --from-paths . --ignore-src --rosdistro noetic -y'

export ROSCONSOLE_FORMAT='[${severity}](${node}): [${time}] ${message}'
alias python=python3

echo "performance" | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null 2>&1

grep_all() { grep -rn '.' -e "$1"; }
docker_exec () { if [[ $(docker container ls -q | wc -l) -eq 1 ]]; then docker exec -it $(docker container ls -q) bash -c "su user"; else echo "wrong number of containers running"; fi; }
id_rsa_to_container() { 
  has_input_args=$(if [[ $(for i in $@; do echo $i; done | wc -l) -eq 0 ]]; then echo false; else echo true; fi)
  if [[ $has_input_args == 'true' ]]; then 
    for container in $@; do 
      docker exec -it $container bash -c "gosu user mkdir /home/user/.ssh"
      docker cp ~/.ssh/id_rsa ${container}:/home/user/.ssh/
    done
  else
    if [ $(which docker | wc -l) -eq 0 ] ; then
      echo "Docker not found. Are you on the host?"
      elif [ $(docker container ls -q | wc -l) -eq 0 ]; then
      echo "No currently running containers"
      elif [ $(docker container ls -q | wc -l) -eq 1 ]; then
      echo "Copying id_rsa to container $(docker container ls -q)"
      docker cp ~/.ssh/id_rsa $(docker container ls -q):/home/user/.ssh/
      elif [ $(docker container ls -q | wc -l) -gt 1 ]; then
      echo "More than one container is running"
    fi
  fi
}
git_add_ssh() { eval "$(ssh-agent -s)"; ssh-add ~/.ssh/id_rsa ; }
git config --global alias.sshify '!f() { git remote set-url origin $(git remote get-url origin | sed -En "s/https:\/\/github.com\//git@github.com:/p") ; }; f'
git config --global alias.unsshify '!f() { git remote set-url origin $(git remote get-url origin | sed -En "s/git@github.com:/https:\/\/github.com\//p") ; }; f'
git_print_log() { git log --graph --oneline --decorate --all ; }
vscode_dev_container() { bash <(curl -s https://raw.githubusercontent.com/shadow-robot/sr-build-tools/lint/ansible/roles/dev_machine/files/vs_code_setup.sh) ; }
aws_ecr_public() { aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/shadowrobot; }
aws_ecr_private() { aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin 080653068785.dkr.ecr.eu-west-2.amazonaws.com; }
cd_ltr(){ cd $1$(ls $1 -ltr -d */ | tail -n 1 | awk '{print $9}'); }
cats() { for input_file in $@; do echo -e "${input_file}: \n"; highlight -O ansi --force $input_file; echo -e "\n"; done; }
catsn() { for input_file in $@; do echo -e "${input_file}: \n"; highlight -O ansi --force -n $input_file; echo -e "\n"; done; }
sr_diagnostics() { rostopic echo --filter "m.status[0].name == 'Realtime Control Loop'" /diagnostics; }
network_speed() { speedometer -l  -r $1 -t $1 -m $(( 1024 * 1024 * 3 / 2 )) ; }
alias cgrep="grep --color=always"
ps_aux() { ps aux | cgrep $1 | grep -v grep ; }
ps_aux_command() { ps -e -o command | cgrep $1 | grep -v grep ; }
kill_any_process() { ps_aux_command $1; conf="$(confirm "kill these processes? [Y/n]")"; if [[ $conf == "y" ]]; then echo "killing..."; sudo kill -9 $(ps_aux $1 | awk {'print $2}'); sleep 1; echo "remaining: "; ps_aux_command $1 else echo "not killing"; fi ; }
